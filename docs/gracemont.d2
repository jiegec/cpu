cpu : Intel Alder Lake Gracement CPU {
  frontend: Frontend {
    bp: Branch Predictor {
      # Source: Chips and Cheese
      l1btb: 1024-entry L1 BTB

      # Source: Chips and Cheese
      l2btb: 5120-way L2 BTB
    }

    l1ic: L1 IC {
      # Source: Chips and Cheese
      itlb: 64-entry ITLB

      # Source: Chips and Cheese, Intel
      l1ic: 64KB 8-way L1 IC
    }

    # Source: Chips and Cheese
    fq: 2x Fetch Queue
    bp -> fq
    fq -> l1ic

    iq1: Instruction Queue \#1
    l1ic -> iq1

    # Source: Chips and Cheese
    decode1: 3-way Decode \#1
    iq1 -> decode1

    # Source: Chips and Cheese
    uop1: UOP Queue \#1
    decode1 -> uop1

    iq2: Instruction Queue \#2
    l1ic -> iq2

    # Source: Chips and Cheese
    decode2: 3-way Decode \#2
    iq2 -> decode2

    # Source: Chips and Cheese
    uop2: UOP Queue \#2
    decode2 -> uop2

    # Source: Chips and Cheese, Intel
    rename: 5-way Rename {
      Move Elimination
      Zero Idiom
    }
    uop1 -> rename
    uop2 -> rename
  }

  backend: Backend {
    # Source: Chips and Cheese, Intel
    rob: 256-entry ROB

    int: Integer {
      # Source: Chips and Cheese
      irf: 214-entry Integer Register File

      # Source: Chips and Cheese
      sched1: 15-entry ALU Scheduler \#1

      # Source: Chips and Cheese, Intel
      pipe1: Port 0 {
        ALU
        SHIFT
      }
      sched1 -> irf -> pipe1

      # Source: Chips and Cheese
      sched2: 16-entry ALU Scheduler \#2

      # Source: Chips and Cheese
      pipe2: Port 1 {
        ALU
        SHIFT
        INT MUL
        INT DIV
      }
      sched2 -> irf -> pipe2

      # Source: Chips and Cheese
      sched3: 16-entry ALU Scheduler \#3

      # Source: Chips and Cheese, Intel
      pipe3: Port 2 {
        ALU
        SHIFT
        INT MUL
        INT DIV
        PDEP
      }
      sched3 -> irf -> pipe3

      # Source: Chips and Cheese
      sched4: 16-entry ALU Scheduler \#4

      # Source: Chips and Cheese, Intel
      pipe4: Port 3 {
        ALU
        SHIFT
      }
      sched4 -> irf -> pipe4

      # Source: Chips and Cheese
      sched5: 42-entry Scheduler \#5

      # Source: Chips and Cheese, Intel
      pipe5: Port 30 {
        JMP/Branch
      }
      sched5 -> irf -> pipe5

      # Source: Chips and Cheese, Intel
      pipe6: Port 31 {
        JMP/Branch
      }
      sched5 -> irf -> pipe6
    }

    rob -> int.sched1
    rob -> int.sched2
    rob -> int.sched3
    rob -> int.sched4
    rob -> int.sched5

    mem: Memory {
      # Source: Chips and Cheese
      nsq: 22-entry Non-Scheduling Queue

      # Source: Chips and Cheese
      sched2: 22-entry Scheduler
      nsq -> sched2

      # Source: Chips and Cheese, Intel
      pipe7: Port 10 {
        Load AGU
      }
      sched2 -> pipe7

      # Source: Chips and Cheese, Intel
      pipe8: Port 11 {
        Load AGU
      }
      sched2 -> pipe8

      # Source: Chips and Cheese, Intel
      pipe9: Port 12 {
        Store AGU
      }
      sched2 -> pipe9

      # Source: Chips and Cheese, Intel
      pipe10: Port 13 {
        Store AGU
      }
      sched2 -> pipe10

      # Source: Chips and Cheese, Intel
      pipe11: Port 8 {
        Store Data
      }
      sched2 -> pipe11

      # Source: Chips and Cheese, Intel
      pipe12: Port 9 {
        Store Data
      }
      sched2 -> pipe12

      lsu: LSU {
        # Source: Chips and Cheese
        80-entry Load Queue
        50-entry Store Queue
      }

      pipe7 -> lsu
      pipe8 -> lsu
      pipe9 -> lsu
      pipe10 -> lsu
      pipe11 -> lsu
      pipe12 -> lsu
    }
    rob -> mem.nsq

    vec: Vector/FP {
      # Source: Chips and Cheese
      nsq: 56-entry Non-Scheduling Queue

      # Source: Chips and Cheese
      vrf: 207-entry 128b Vector Register File

      # Source: Chips and Cheese
      sched3: 18-entry Scheduler
      nsq -> sched3

      # Source: Chips and Cheese, Intel
      pipe13: Port 28 {
        FP Store Data
      }
      sched3 -> vrf -> pipe13

      # Source: Chips and Cheese, Intel
      pipe14: Port 29 {
        FP Store Data
      }
      sched3 -> vrf -> pipe14

      # Source: Chips and Cheese
      sched4: 35-entry Scheduler
      nsq -> sched4

      # Source: Chips and Cheese, Intel
      pipe15: Port 20 {
        INT Vec ALU
        INT Vec MUL
        FMA
        FADD
        FMUL
        AES
        FDIV
        SHA
      }
      sched4 -> vrf -> pipe15

      # Source: Chips and Cheese, Intel
      pipe16: Port 21 {
        INT Vec ALU
        FMA
        FADD
        FMUL
        AES
      }
      sched4 -> vrf -> pipe16

      # Source: Chips and Cheese, Intel
      pipe17: Port 22 {
        INT Vec ALU
      }
      sched4 -> vrf -> pipe17
    }
    rob -> vec.nsq
  }

  frontend.rename -> backend.rob

  mem: Memory {
    l1: L1 DC {
      # Source: Chips and Cheese
      l1dtlb: 48-entry L1 DTLB

      # Source: Chips and Cheese
      l1dc: 32KB 8-way L1DC
    }

    l2: L2 {
      # Source: Chips and Cheese, Intel
      l2tlb: 2048-entry 4-way L2 TLB

      # Source: Chips and Cheese, Intel
      l2dc: 2MB 16-way Shared L2 Cache
    }

    # Source: Chips and Cheese, Intel
    l1 -> l2

    l3: L3 {
      # Source: Chips and Cheese
      l3dc: 30MB 12-way L3 Cache
    }
    l2 -> l3
  }
  frontend.l1ic -> mem.l2
  backend.mem.lsu -> mem.l1

  info: |md
    Drawn by Jiajie Chen @jiegec

    Based on data from Chips and Cheese, Intel
  |
}